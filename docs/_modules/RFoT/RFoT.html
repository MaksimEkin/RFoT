
<!DOCTYPE html>

<html lang="Python">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RFoT.RFoT &#8212; RFoT v0.0.1 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="Python">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">RFoT v0.0.1 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Contents:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../RFoT_API.html">
   RFoT Package API
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../RFoT.html">
   RFoT Code Base
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../RFoT.clustering.html">
     RFoT.clustering package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../RFoT.utilities.html">
     RFoT.utilities package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for RFoT.RFoT</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tensor decomposition is a powerful unsupervised Machine Learning method that enables the modeling of multi-dimensional data, including malware data. We introduce a novel ensemble semi-supervised classification algorithm, named Random Forest of Tensors (RFoT), that utilizes tensor decomposition to extract the complex and multi-faceted latent patterns from data. Our hybrid model leverages the strength of multi-dimensional analysis combined with clustering to capture the sample groupings in the latent components, whose combinations distinguish malware and benign-ware. The patterns extracted from a given data with tensor decomposition depend upon the configuration of the tensor such as dimension, entry, and rank selection. To capture the unique perspectives of different tensor configurations, we employ the “wisdom of crowds” philosophy and make use of decisions made by the majority of a randomly generated ensemble of tensors with varying dimensions, entries, and ranks.</span>

<span class="sd">As the tensor decomposition backend, RFoT offers two CPD algorithms. First, RFoT package includes the Python implementation of **CP-ALS** algorithm that was originally introduced in the `MATLAB Tensor Toolbox &lt;https://www.tensortoolbox.org/cp.html&gt;`_  :cite:p:`TTB_Software,Bader2006,Bader2008`. CP-ALS backend can also be used to **decompose each random tensor in a parallel manner**. RFoT can also be used with the Python implentation of the **CP-APR** algorithm with the **GPU capability** :cite:p:`10.1145/3519602`. Use of CP-APR backend allows decomposing each random tensor configuration both in an **embarrassingly parallel fashion in a single GPU**, and in a **multi-GPU parallel execution**.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">pyCP_ALS</span> <span class="kn">import</span> <span class="n">CP_ALS</span>
<span class="kn">from</span> <span class="nn">pyCP_APR</span> <span class="kn">import</span> <span class="n">CP_APR</span>

<span class="kn">from</span> <span class="nn">.utilities.bin_columns</span> <span class="kn">import</span> <span class="n">bin_columns</span>
<span class="kn">from</span> <span class="nn">.utilities.sample_tensor_configs</span> <span class="kn">import</span> <span class="n">setup_tensors</span>
<span class="kn">from</span> <span class="nn">.utilities.build_tensor</span> <span class="kn">import</span> <span class="n">setup_sptensor</span>
<span class="kn">from</span> <span class="nn">.utilities.istarmap</span> <span class="kn">import</span> <span class="n">istarmap</span>

<span class="kn">from</span> <span class="nn">.clustering.gmm</span> <span class="kn">import</span> <span class="n">gmm_cluster</span>
<span class="kn">from</span> <span class="nn">.clustering.ms</span> <span class="kn">import</span> <span class="n">ms_cluster</span>
<span class="kn">from</span> <span class="nn">.clustering.component</span> <span class="kn">import</span> <span class="n">component_cluster</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">operator</span>


<div class="viewcode-block" id="RFoT"><a class="viewcode-back" href="../../RFoT_API.html#RFoT.RFoT.RFoT">[docs]</a><span class="k">class</span> <span class="nc">RFoT</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">max_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">min_rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">max_rank</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                 <span class="n">min_dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">max_dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">min_cluster_search</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">max_cluster_search</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                 <span class="n">component_purity_tol</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">cluster_purity_tol</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                 <span class="n">n_estimators</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                 <span class="n">rank</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                 <span class="n">clustering</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">,</span>
                 <span class="n">decomp</span><span class="o">=</span><span class="s2">&quot;cp_als&quot;</span><span class="p">,</span>
                 <span class="n">zero_tol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span>
                 <span class="n">dont_bin</span><span class="o">=</span><span class="nb">list</span><span class="p">(),</span>
                 <span class="n">bin_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">bin_entry</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">bin_max_map</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span><span class="p">,</span>
                 <span class="s2">&quot;bin&quot;</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">3</span><span class="p">},</span>
                 <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                 <span class="n">n_iters</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">decomp_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fixsigns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">n_gpus</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">gpu_id</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initilize the **RFoT.RFoT** class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_depth : int, optional</span>
<span class="sd">            Maximum number of times to run RFoT. The default is 1.</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * If ``max_depth=1``, data is fit with RFoT once.</span>
<span class="sd">                * Otherwise, when ``max_depth`` is more than 1, each corresponding fit of the data with RFoT will work on the abstaining predictions from the prior fit.</span>
<span class="sd">            </span>
<span class="sd">        min_rank : int, optional</span>
<span class="sd">            Minimum tensor rank R to be randomly sampled. The default is 2.</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * Should be more than 1. ``min_rank`` should be less than ``max_rank``.</span>
<span class="sd">                * Only used when ``rank=&quot;random&quot;``.</span>


<span class="sd">        max_rank : int, optional</span>
<span class="sd">            Maximum tensor rank R to be randomly sampled. The default is 20.</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * ``max_rank`` should be more than ``min_rank``.</span>
<span class="sd">                * Only used when ``rank=&quot;random&quot;``.</span>


<span class="sd">        min_dimensions : int, optional</span>
<span class="sd">            When randomly sampling tensor configurations, minimum number of dimensions a tensor should have within the ensemble of random tensor configurations. The default is 3.</span>

<span class="sd">        max_dimensions : int, optional</span>
<span class="sd">            When randomly sampling tensor configurations, maximum number of dimensions a tensor should have within the ensemble of random tensor configurations. The default is 3.</span>

<span class="sd">        min_cluster_search : int, optional</span>
<span class="sd">            When searching for the number of clusters via likelihood in GMM, minimum number of clusters to try. The default is 2.</span>
<span class="sd">        max_cluster_search : int, optional</span>
<span class="sd">            When searching for the number of clusters via likelihood in GMM, maximum number of clusters to try. The default is 12.</span>
<span class="sd">        component_purity_tol : float or int, optional</span>
<span class="sd">            The purity score threshold for the latent factors. The default is -1.\n</span>
<span class="sd">            This threshold is calculated based on the known instances in the component.\n</span>
<span class="sd">            If the purity score of the latent factor is lower then the threshold ``component_purity_tol``, component is discarded and would not be used in obtaining clusters.</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * By default ``component_purity_tol=-1``.</span>
<span class="sd">                * When ``component_purity_tol=-1``, component uniformity is not used in deciding whether to discard the components, and only ``cluster_purity_tol`` is used.</span>
<span class="sd">                * Either ``component_purity_tol`` or ``cluster_purity_tol`` must be more than 0.</span>
<span class="sd">            </span>
<span class="sd">        cluster_purity_tol : float, optional</span>
<span class="sd">            The purity score threshold for the clusters. The default is 0.9.</span>
<span class="sd">            This threshold is calculated based on the known instances in the cluster.\n</span>
<span class="sd">            If the purity score of the cluster is lower then the threshold ``cluster_purity_tol``, cluster is discarded and would not be used in the semi-supervised class voting of the unknown samples in the same cluster.</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * When ``cluster_purity_tol=-1``, cluster uniformity is not used in deciding whether to discard the clusters, and only ``component_purity_tol`` is used. </span>
<span class="sd">                * Either ``component_purity_tol`` or ``cluster_purity_tol`` must be more than 0.</span>
<span class="sd">            </span>
<span class="sd">        n_estimators : int, optional</span>
<span class="sd">            Number of random tensor configurations in the ensemble. The default is 80.</span>
<span class="sd">            </span>
<span class="sd">            .. caution::</span>
<span class="sd">                * Based on the hyper-parameter configurations, and the number of features in the dataset, it is possible to have less number of random tensor configurations than the one specified in ``n_estimators``.</span>
<span class="sd">            </span>
<span class="sd">        rank : int or string, optional</span>
<span class="sd">            Method for assigning rank for each random tensor to be decomposed. The default is &quot;random&quot;.\n</span>
<span class="sd">            When ``rank=&quot;random&quot;``, the rank for decomposition is sampled randomly from the range (``min_rank``, ``max_rank``).\n</span>
<span class="sd">            All the tensors in the ensemble can also be decomposed with same rank (example: ``rank=2``).</span>
<span class="sd">            </span>
<span class="sd">        clustering : string, optional</span>
<span class="sd">            Clustering method to be used for capturing the patterns from the latent factors. The default is &quot;ms&quot;.\n</span>
<span class="sd">            </span>
<span class="sd">            .. admonition:: Options</span>
<span class="sd">            </span>
<span class="sd">                * ``clustering=&quot;ms&quot;`` (Mean Shift)</span>
<span class="sd">                * ``clustering=&quot;component&quot;``, </span>
<span class="sd">                * ``clustering=&quot;gmm&quot;`` (Gaussian Mixture Model).</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        decomp : string, optional</span>
<span class="sd">            Tensor decomposition backend/algorithm to be used. The default is &quot;cp_als&quot;.\n</span>
<span class="sd">            </span>
<span class="sd">            .. admonition:: Options</span>
<span class="sd">            </span>
<span class="sd">                * ``decomp=&quot;cp_als&quot;`` (Alternating least squares for CANDECOMP/PARAFAC Decomposition), * ``decomp=&quot;cp_apr&quot;`` (CANDECOMP/PARAFAC Alternating Poisson Regression) </span>
<span class="sd">                * ``decomp=&quot;cp_apr_gpu&quot;`` (CP-APR with GPU)</span>
<span class="sd">                * ``decomp=&quot;debug&quot;``</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * GPU is used when ``decomp=&quot;cp_apr_gpu&quot;``.</span>
<span class="sd">                * ``decomp=&quot;debug&quot;`` allows serial computation where any error or warning would be raised to the user level.</span>
<span class="sd">            </span>
<span class="sd">        zero_tol : float, optional</span>
<span class="sd">            Samples who are close to the zero, where closeness defined by ``zero_tol``, are removed from the latent factor. The default is 1e-08.</span>
<span class="sd">            </span>
<span class="sd">        dont_bin : list, optional</span>
<span class="sd">            List of column (feature) indices whose values should not be binned. The default is list().</span>
<span class="sd">            </span>
<span class="sd">        bin_scale : float, optional</span>
<span class="sd">            When using a given column (feature) as a tensor dimension, the feature values are binned to create feature value to tensor dimension mapping. This allows a feature value to be represented by an index in the tensor dimension for that feature. The default is 1.0.\n</span>
<span class="sd">            When ``bin_scale=1.0``, the size of the dimension that represents the given feature will be equal to the number of unique values in that column (feature).</span>
<span class="sd">            </span>
<span class="sd">            .. seealso::</span>
<span class="sd">                * See `Pandas Cut &lt;https://pandas.pydata.org/docs/reference/api/pandas.cut.html&gt;`_ for value binning.</span>
<span class="sd">            </span>
<span class="sd">        bin_entry : bool, optional</span>
<span class="sd">            If ``bin_entry=True``, the features that are used as tensor entry are also binned. The default is False.</span>
<span class="sd">            </span>
<span class="sd">        bin_max_map : dict, optional</span>
<span class="sd">            ``bin_max_map`` prevents any dimension of any of the tensors in the ensemble to be too large. The default is ``bin_max_map={&quot;max&quot;: 10 ** 6, &quot;bin&quot;: 10 ** 3}``. \n</span>
<span class="sd">            Specifically, ``bin_max_map[&quot;bin&quot;]`` is used to determine the size of the dimension when:</span>
<span class="sd">            </span>
<span class="sd">            :math:`bin\_scale \cdot |f_i| &gt; bin\_max\_map[&quot;max&quot;]`</span>

<span class="sd">            </span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            CP-ALS hyper-parameter. The default is 1e-4.</span>
<span class="sd">        n_iters : int, optional</span>
<span class="sd">             Maximum number of iterations (epoch) to run the tensor decomposition algorithm. The default is 50.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``verbose=True``, progress of the method is displayed. The default is True.</span>
<span class="sd">        decomp_verbose : bool, optional</span>
<span class="sd">            If ``decomp_verbose=True``, progress of the tensor decomposition backend is displayed for each random tensor. The default is False.</span>
<span class="sd">        fixsigns : bool, optional</span>
<span class="sd">            CP-ALS hyper-parameter. The default is True.</span>
<span class="sd">        random_state : int, optional</span>
<span class="sd">            Random seed. The default is 42.</span>
<span class="sd">        n_jobs : int, optional</span>
<span class="sd">            Number of prallel tensor decompositions to perform when decomposing the random tensors from the ensemble. The default is 1.</span>
<span class="sd">        n_gpus : int, optional</span>
<span class="sd">            Number of GPUs. The default is 1.</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * Only used when ``decomp=&quot;cp_apr_gpu&quot;``.</span>
<span class="sd">                * When ``n_gpus`` is more than 1, and when ``n_jobs`` is more than one, multi-GPU parallel execution is performed. For example, ``n_gpus=2`` and ``n_jobs=2`` will use 2 GPUs, and 1 job will be run on each GPU in parallel.</span>
<span class="sd">            </span>
<span class="sd">        gpu_id : int, optional</span>
<span class="sd">            GPU device ID when using GPU. The default is 0.</span>
<span class="sd">            </span>
<span class="sd">            .. note::</span>
<span class="sd">                * Only used when ``decomp=&quot;cp_apr_gpu&quot;``.</span>
<span class="sd">                * Not considered when ``n_gpus`` is more than 1.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            Invalid parameter selection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="n">max_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_rank</span> <span class="o">=</span> <span class="n">min_rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_rank</span> <span class="o">=</span> <span class="n">max_rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_dimensions</span> <span class="o">=</span> <span class="n">min_dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_dimensions</span> <span class="o">=</span> <span class="n">max_dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_search</span> <span class="o">=</span> <span class="n">min_cluster_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cluster_search</span> <span class="o">=</span> <span class="n">max_cluster_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_purity_tol</span> <span class="o">=</span> <span class="n">component_purity_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_purity_tol</span> <span class="o">=</span> <span class="n">cluster_purity_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustering</span> <span class="o">=</span> <span class="n">clustering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="o">=</span> <span class="n">decomp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_tol</span> <span class="o">=</span> <span class="n">zero_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dont_bin</span> <span class="o">=</span> <span class="n">dont_bin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_scale</span> <span class="o">=</span> <span class="n">bin_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_entry</span> <span class="o">=</span> <span class="n">bin_entry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_max_map</span> <span class="o">=</span> <span class="n">bin_max_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span> <span class="o">=</span> <span class="n">n_iters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomp_verbose</span> <span class="o">=</span> <span class="n">decomp_verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixsigns</span> <span class="o">=</span> <span class="n">fixsigns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_gpus</span> <span class="o">=</span> <span class="n">n_gpus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpu_id</span> <span class="o">=</span> <span class="n">gpu_id</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allowed_decompositions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cp_als&quot;</span><span class="p">,</span> <span class="s2">&quot;cp_apr&quot;</span><span class="p">,</span> <span class="s2">&quot;cp_apr_gpu&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">]</span>


        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_purity_tol</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_purity_tol</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;Cluster purity and/or component purity must be &gt;0&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering</span> <span class="o">==</span> <span class="s2">&quot;gmm&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">gmm_cluster</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering</span> <span class="o">==</span> <span class="s2">&quot;ms&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">ms_cluster</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering</span> <span class="o">==</span> <span class="s2">&quot;component&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">component_cluster</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown clustering method is chosen.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RFoT.get_params"><a class="viewcode-back" href="../../RFoT_API.html#RFoT.RFoT.RFoT.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parameters of the RFoT object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Parameters and data stored in the RFoT object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="RFoT.set_params"><a class="viewcode-back" href="../../RFoT_API.html#RFoT.RFoT.RFoT.set_params">[docs]</a>    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to set the parameters of RFoT object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **parameters : dict</span>
<span class="sd">            Dictionary of parameters where keys are the variable names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            RFoT object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="RFoT.predict"><a class="viewcode-back" href="../../RFoT_API.html#RFoT.RFoT.RFoT.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Semi-supervised prediction of the unknown samples (with labels -1) based on the known samples.</span>

<span class="sd">        .. important::</span>
<span class="sd">            * Use -1 for the unknown samples.</span>
<span class="sd">            * In returned ``y_pred``, samples with -1 predictions are said to be abstaining predictions (i.e. model says &quot;we do not know that the label for that sample is&quot;).</span>
<span class="sd">            * Returned ``y_pred`` includes both known and unknown samples, where the labels of unknown samples may have changed from the original ``y``.</span>

<span class="sd">        .. admonition:: Example Usage</span>
<span class="sd">        </span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                from RFoT import RFoT</span>
<span class="sd">                from sklearn import datasets</span>
<span class="sd">                from sklearn.metrics import f1_score</span>
<span class="sd">                import numpy as np</span>

<span class="sd">                # load the dataset</span>
<span class="sd">                iris = datasets.load_iris()</span>
<span class="sd">                X = iris[&quot;data&quot;]</span>
<span class="sd">                y = (iris[&quot;target&quot;] == 2).astype(np.int) </span>

<span class="sd">                y_true = y.copy()</span>
<span class="sd">                y_experiment = y_true.copy()</span>

<span class="sd">                # label 30% some as unknown</span>
<span class="sd">                rng = np.random.RandomState(42)</span>
<span class="sd">                random_unlabeled_points = rng.rand(y_experiment.shape[0]) &lt; 0.3</span>
<span class="sd">                y_experiment[random_unlabeled_points] = -1</span>

<span class="sd">                # predict with RFoT</span>
<span class="sd">                model = RFoT(</span>
<span class="sd">                        bin_scale=1,</span>
<span class="sd">                        max_dimensions=3,</span>
<span class="sd">                        component_purity_tol=1.0,</span>
<span class="sd">                        min_rank=2,</span>
<span class="sd">                        max_rank=3,</span>
<span class="sd">                        n_estimators=50,</span>
<span class="sd">                        bin_entry=True,</span>
<span class="sd">                        clustering=&quot;ms&quot;,</span>
<span class="sd">                        max_depth=2,</span>
<span class="sd">                        n_jobs=50,</span>
<span class="sd">                )</span>
<span class="sd">                y_pred = model.predict(X, y_experiment)</span>

<span class="sd">                # look at results</span>
<span class="sd">                unknown_indices = np.argwhere(y_experiment == -1).flatten()</span>
<span class="sd">                did_predict_indices = np.argwhere(y_pred[unknown_indices] != -1).flatten()</span>
<span class="sd">                abstaining_count = len(np.argwhere(y_pred == -1))</span>
<span class="sd">                f1 = f1_score(</span>
<span class="sd">                    y_true[unknown_indices][did_predict_indices],</span>
<span class="sd">                    y_pred[unknown_indices][did_predict_indices],</span>
<span class="sd">                    average=&quot;weighted&quot;,</span>
<span class="sd">                )</span>

<span class="sd">                print(&quot;------------------------&quot;)</span>
<span class="sd">                print(&quot;Num. of Abstaining&quot;, abstaining_count)</span>
<span class="sd">                print(&quot;Percent Abstaining&quot;, (abstaining_count / len(unknown_indices)) * 100, &quot;%&quot;)</span>
<span class="sd">                print(&quot;F1=&quot;, f1)</span>

<span class="sd">        .. admonition:: Example Usage</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                # y is the vector of known and unknown labels passed to RFoT</span>
<span class="sd">                # y_pred is the prediction returned by RFoT</span>
<span class="sd">                # y_true is the ground truth</span>

<span class="sd">                import numpy as np</span>
<span class="sd">                from sklearn.metrics import f1_score</span>

<span class="sd">                unknown_indices = np.argwhere(y == -1).flatten()</span>
<span class="sd">                did_predict_indices = np.argwhere(y_pred[unknown_indices] != -1).flatten()</span>
<span class="sd">                abstaining_count = len(np.argwhere(y_pred == -1))</span>

<span class="sd">                f1 = f1_score(</span>
<span class="sd">                    y_true[unknown_indices][did_predict_indices],</span>
<span class="sd">                    y_pred[unknown_indices][did_predict_indices],</span>
<span class="sd">                    average=&quot;weighted&quot;,</span>
<span class="sd">                )</span>

<span class="sd">                print(&quot;Num. of Abstaining&quot;, abstaining_count)</span>
<span class="sd">                print(&quot;Percent Abstaining&quot;, (abstaining_count / len(unknown_indices)) * 100, &quot;%&quot;)</span>
<span class="sd">                print(&quot;F1=&quot;, f1)</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.array</span>
<span class="sd">            Features matrix X where columns are the m features and rows are the n samples.</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Vector of size n with the label for each sample. Unknown samples have the labels -1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred : np.ndarray</span>
<span class="sd">            Predictions made over the original y. Known samples are kept as is. Unknown samples</span>
<span class="sd">            that are no longer labeled as -1 did have prediction. Samples that are still -1 are</span>
<span class="sd">            the abstaining predictions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># Input verification</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No unknown samples found. Label unknown with -1 in y.&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;Do not use -2 as the label as it is internally used!&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">y</span>
        <span class="p">),</span> <span class="s2">&quot;Number of samples does not match the number of labels!&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;No unknown samples found! Use -1 in labels to mark the unknown samples.&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># Setup</span>
        <span class="c1">#</span>

        <span class="c1"># add column to X to serve as sample IDs</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># convert the features matrix into dataframe</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">y_pred_flag</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">X_curr</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">y_curr</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">curr_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

        <span class="c1">#</span>
        <span class="c1"># Main loop, depth</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">):</span>
            <span class="n">n_abstaining</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">y_pred_curr</span><span class="p">,</span> <span class="n">predicted_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="p">(</span><span class="n">X_curr</span><span class="p">,</span> <span class="n">y_curr</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
            <span class="n">y_pred</span><span class="p">[</span><span class="n">curr_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_curr</span>
            <span class="n">y_pred_flag</span><span class="p">[</span><span class="n">curr_indices</span><span class="p">[</span><span class="n">predicted_indices</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">n_abstaining_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># no change in abstaining predictions, no need to continue</span>
            <span class="k">if</span> <span class="n">n_abstaining_new</span> <span class="o">==</span> <span class="n">n_abstaining</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># form the data for the next depth</span>
            <span class="n">curr_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y_pred_flag</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="n">X_curr</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">curr_indices</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">X_curr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_curr</span><span class="p">))</span>
            <span class="n">y_curr</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">curr_indices</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">y_pred</span></div>

    <span class="k">def</span> <span class="nf">_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates random tensor configurations, then builds the tensors in COO format.</span>
<span class="sd">        These tensors are then decomposed and the sample patters are captured with clustering</span>
<span class="sd">        over the latent factors for the first dimension. Then semi-supervised voting</span>
<span class="sd">        is performed over the clusters. These votes are returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.array</span>
<span class="sd">            Features matrix X where columns are the m features and rows are the n samples.</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Vector of size n with the label for each sample. Unknown samples have the labels -1.</span>
<span class="sd">        depth : int</span>
<span class="sd">            Number of times to run RFoT.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred : np.ndarray</span>
<span class="sd">            Predictions made over the original y. Known samples are kept as is. Unknown samples</span>
<span class="sd">            that are no longer labeled as -1 did have prediction. Samples that are still -1 are</span>
<span class="sd">            the abstaining predictions.</span>
<span class="sd">        predicted_indices : np.ndarray</span>
<span class="sd">            The indices in y_pred where unknown labels did have prediction values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># unique classes</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">classes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">classes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>

        <span class="c1">#</span>
        <span class="c1"># Sample the first set of tensor options</span>
        <span class="c1">#</span>
        <span class="n">tensor_configs</span> <span class="o">=</span> <span class="n">setup_tensors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_dimensions</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_dimensions</span><span class="p">,</span>
            <span class="n">X</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">+</span> <span class="n">depth</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_rank</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_rank</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Work on each random tensor configuration</span>
        <span class="c1">#</span>
        <span class="n">tensor_votes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_configs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cp_apr_gpu&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_gpus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">config</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpu_id</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">config</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">idx</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">n_gpus</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">config</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cp_als&quot;</span><span class="p">,</span> <span class="s2">&quot;cp_apr&quot;</span><span class="p">]:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tv</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">istarmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_votes</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tasks</span><span class="p">),</span>
                <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="n">tensor_votes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cp_apr_gpu&quot;</span><span class="p">]:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tv</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">istarmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_votes</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tasks</span><span class="p">),</span>
                <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="n">tensor_votes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>

            <span class="c1">#for task in tqdm.tqdm(tasks, total=len(tasks), disable=not (self.verbose)):</span>
            <span class="c1">#    tv = self._get_tensor_votes(config=task[0], X=task[1], y=task[2], gpu_id=task[3])</span>
            <span class="c1">#    tensor_votes.append(tv)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;debug&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tasks</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)):</span>
                <span class="n">tv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_votes</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">task</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="o">=</span><span class="n">task</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">task</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">tensor_votes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Combine votes from each tensor</span>
        <span class="c1">#</span>
        <span class="n">votes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tv</span> <span class="ow">in</span> <span class="n">tensor_votes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sample_idx</span><span class="p">,</span> <span class="n">sample_votes</span> <span class="ow">in</span> <span class="n">tv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="n">votes</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sample_votes</span><span class="p">):</span>
                        <span class="n">votes</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">votes</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_votes</span>

        <span class="c1">#</span>
        <span class="c1"># Max vote on the results of current depth</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">votes</span> <span class="o">=</span> <span class="n">votes</span>
        <span class="n">predicted_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sample_idx</span><span class="p">,</span> <span class="n">sample_votes</span> <span class="ow">in</span> <span class="n">votes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># no decision was made (50-50)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sample_votes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">y_pred</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">max_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sample_votes</span><span class="p">)</span>
            <span class="n">max_index</span> <span class="o">=</span> <span class="n">sample_votes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span>
            <span class="n">y_pred</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_index</span>
            <span class="n">predicted_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">predicted_indices</span>

    <span class="k">def</span> <span class="nf">_get_tensor_votes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">gpu_id</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up the tensor decomposition backend. Then bins the features to build the given</span>
<span class="sd">        current tensor. Then the tensor is decomposed and the sample patters are captured with</span>
<span class="sd">        clustering over the latent factors for the first dimension. Then semi-supervised voting</span>
<span class="sd">        is performed over the clusters. These votes are returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config : dict</span>
<span class="sd">            Dictionary of tensor configuration.</span>
<span class="sd">        X : np.array</span>
<span class="sd">            Features matrix X where columns are the m features and rows are the n samples.</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Vector of size n with the label for each sample. Unknown samples have the labels -1.</span>
<span class="sd">        gpu_id : int, optional</span>
<span class="sd">            If running CP-APR, which GPU to use. The default is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        votes : dict</span>
<span class="sd">            Dictionary of votes for the samples.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># setup backend</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cp_als&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">]:</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">CP_ALS</span><span class="p">(</span>
                <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span>
                <span class="n">n_iters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decomp_verbose</span><span class="p">,</span>
                <span class="n">fixsigns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fixsigns</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cp_apr&quot;</span><span class="p">]:</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">CP_APR</span><span class="p">(</span>
                <span class="n">n_iters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decomp_verbose</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cp_apr_gpu&quot;</span><span class="p">]:</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">CP_APR</span><span class="p">(</span>
                <span class="n">n_iters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decomp_verbose</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;torch&#39;</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="s1">&#39;gpu&#39;</span><span class="p">,</span>
                <span class="n">device_num</span><span class="o">=</span><span class="n">gpu_id</span><span class="p">,</span>
                <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Unknown tensor decomposition method. Choose from: &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_decompositions</span><span class="p">)</span>
            <span class="p">)</span>


        <span class="c1"># original indices</span>
        <span class="n">all_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="n">votes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#</span>
        <span class="c1"># bin the dimensons</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_entry</span><span class="p">:</span>
            <span class="n">curr_entry</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;entry&quot;</span><span class="p">]</span>
            <span class="n">curr_dims</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">]</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="n">bin_columns</span><span class="p">(</span>
                <span class="n">X</span><span class="p">[</span><span class="n">curr_dims</span> <span class="o">+</span> <span class="p">[</span><span class="n">curr_entry</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_max_map</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dont_bin</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_scale</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_entry</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;entry&quot;</span><span class="p">]</span>
            <span class="n">curr_dims</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">]</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="n">bin_columns</span><span class="p">(</span>
                <span class="n">X</span><span class="p">[</span><span class="n">curr_dims</span> <span class="o">+</span> <span class="p">[</span><span class="n">curr_entry</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_max_map</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dont_bin</span> <span class="o">+</span> <span class="p">[</span><span class="n">curr_entry</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_scale</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Factorize the current tensor</span>
        <span class="c1">#</span>
        <span class="n">curr_tensor</span> <span class="o">=</span> <span class="n">setup_sptensor</span><span class="p">(</span><span class="n">curr_df</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>

        <span class="n">decomp</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">curr_tensor</span><span class="p">[</span><span class="s2">&quot;nnz_coords&quot;</span><span class="p">],</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">curr_tensor</span><span class="p">[</span><span class="s2">&quot;nnz_values&quot;</span><span class="p">],</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="k">del</span> <span class="n">backend</span>
        <span class="c1"># use the latent factor representing the samples (mode 0)</span>
        <span class="n">latent_factor_0</span> <span class="o">=</span> <span class="n">decomp</span><span class="p">[</span><span class="s2">&quot;Factors&quot;</span><span class="p">][</span><span class="s2">&quot;0&quot;</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Work on each component</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">latent_factor_0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>

            <span class="n">Mk</span> <span class="o">=</span> <span class="n">latent_factor_0</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>

            <span class="c1">#</span>
            <span class="c1"># mask out elements close to 0</span>
            <span class="c1">#</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">Mk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zero_tol</span><span class="p">)</span>
            <span class="n">M_m</span> <span class="o">=</span> <span class="n">Mk</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">curr_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">known_sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">unknown_sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1">#</span>
            <span class="c1"># Capture clusters from current component</span>
            <span class="c1">#</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;M_k&quot;</span><span class="p">:</span> <span class="n">M_m</span><span class="p">,</span>
                <span class="s2">&quot;min_cluster_search&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_search</span><span class="p">,</span>
                <span class="s2">&quot;max_cluster_search&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cluster_search</span><span class="p">,</span>
                <span class="s2">&quot;random_state&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">n_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># error when clustering this component, skip</span>
                <span class="k">continue</span>

            <span class="c1">#</span>
            <span class="c1"># Calculate Component Quality</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_purity_tol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">purity_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_component_quality</span><span class="p">(</span>
                    <span class="n">n_opt</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">known_sample_indices</span><span class="p">,</span> <span class="n">curr_y</span>
                <span class="p">)</span>

                <span class="c1"># poor component quality, poor purity among clusters, skip component</span>
                <span class="k">if</span> <span class="n">purity_score</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_purity_tol</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="c1">#</span>
            <span class="c1"># Semi-supervised voting</span>
            <span class="c1">#</span>
            <span class="n">votes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cluster_votes</span><span class="p">(</span>
                <span class="n">n_opt</span><span class="p">,</span>
                <span class="n">cluster_labels</span><span class="p">,</span>
                <span class="n">known_sample_indices</span><span class="p">,</span>
                <span class="n">unknown_sample_indices</span><span class="p">,</span>
                <span class="n">curr_y</span><span class="p">,</span>
                <span class="n">all_indices</span><span class="p">,</span>
                <span class="n">mask</span><span class="p">,</span>
                <span class="n">votes</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">votes</span>

    <span class="k">def</span> <span class="nf">_get_cluster_votes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_opt</span><span class="p">,</span>
        <span class="n">cluster_labels</span><span class="p">,</span>
        <span class="n">known_sample_indices</span><span class="p">,</span>
        <span class="n">unknown_sample_indices</span><span class="p">,</span>
        <span class="n">curr_y</span><span class="p">,</span>
        <span class="n">all_indices</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">,</span>
        <span class="n">votes</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs semi-supervised voting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_opt : int</span>
<span class="sd">            Number of clusters.</span>
<span class="sd">        cluster_labels : np.ndarray</span>
<span class="sd">            List if cluster labels for each sample.</span>
<span class="sd">        known_sample_indices : np.ndarray</span>
<span class="sd">            Indices of the known samples.</span>
<span class="sd">        unknown_sample_indices : TYPE</span>
<span class="sd">            Indices of the unknown samples.</span>
<span class="sd">        curr_y : np.ndarray</span>
<span class="sd">            Labels.</span>
<span class="sd">        all_indices : np.ndarray</span>
<span class="sd">            Original indices.</span>
<span class="sd">        mask : np.ndarray</span>
<span class="sd">            Zero tol mask.</span>
<span class="sd">        votes : dict</span>
<span class="sd">            Votes so far.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        votes : dict</span>
<span class="sd">            Updated votes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_opt</span><span class="p">):</span>

            <span class="c1"># current cluster sample informations</span>
            <span class="n">cluster_c_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># empty cluster</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_c_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">cluster_c_known_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                <span class="n">known_sample_indices</span><span class="p">,</span> <span class="n">cluster_c_indices</span>
            <span class="p">)</span>
            <span class="n">cluster_c_unknown_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                <span class="n">unknown_sample_indices</span><span class="p">,</span> <span class="n">cluster_c_indices</span>
            <span class="p">)</span>
            <span class="n">cluster_c_known_labels</span> <span class="o">=</span> <span class="n">curr_y</span><span class="p">[</span><span class="n">cluster_c_known_indices</span><span class="p">]</span>

            <span class="c1"># everyone is known in the cluster</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_c_unknown_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># no known samples in the cluster - abstaining prediction</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_c_known_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># count the known labels in the cluster</span>
            <span class="n">cluster_c_known_label_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">cluster_c_known_labels</span><span class="p">))</span>

            <span class="c1"># cluster quality</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_purity_tol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cluster_quality_score</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="n">cluster_c_known_label_counts</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cluster_c_known_label_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="c1"># cluster quality is poor, skip this cluster</span>
                <span class="k">if</span> <span class="n">cluster_quality_score</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_purity_tol</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="c1"># vote</span>
            <span class="n">vote_label</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">cluster_c_known_label_counts</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">org_unknown_indices</span> <span class="o">=</span> <span class="n">all_indices</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">cluster_c_unknown_indices</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">org_unknown_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">votes</span><span class="p">:</span>
                    <span class="n">votes</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">vote_label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">votes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
                    <span class="n">votes</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">vote_label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">votes</span>

    <span class="k">def</span> <span class="nf">_component_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_opt</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">known_sample_indices</span><span class="p">,</span> <span class="n">curr_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates component quality based on cluster purity score.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_opt : int</span>
<span class="sd">            Number of clusters.</span>
<span class="sd">        cluster_labels : np.ndarray</span>
<span class="sd">            Labels for the samples in the cluster.</span>
<span class="sd">        known_sample_indices : np.ndarray</span>
<span class="sd">            Array of indices for known samples.</span>
<span class="sd">        curr_y : np.ndarray</span>
<span class="sd">            Labels for known and unknown samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Purity score.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">maximums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_opt</span><span class="p">):</span>
            <span class="n">cluster_c_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># empty cluster</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_c_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">cluster_c_known_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                <span class="n">known_sample_indices</span><span class="p">,</span> <span class="n">cluster_c_indices</span>
            <span class="p">)</span>

            <span class="c1"># no known samples in the cluster - abstaining prediction</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_c_known_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">cluster_c_known_labels</span> <span class="o">=</span> <span class="n">curr_y</span><span class="p">[</span><span class="n">cluster_c_known_indices</span><span class="p">]</span>
            <span class="n">cluster_c_known_label_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">cluster_c_known_labels</span><span class="p">))</span>
            <span class="n">maximums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">cluster_c_known_label_counts</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_c_known_indices</span><span class="p">)</span>

        <span class="c1"># if none of the clusters had known instances</span>
        <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="n">purity_score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">maximums</span><span class="p">)</span> <span class="o">/</span> <span class="n">total</span>

        <span class="k">return</span> <span class="n">purity_score</span></div>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Maksim E. Eren<br/>
  
      &copy; Copyright 2022, Maksim E. Eren.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>